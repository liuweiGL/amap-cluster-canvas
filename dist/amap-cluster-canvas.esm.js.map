{"version":3,"file":"amap-cluster-canvas.esm.js","sources":["../src/canvas.js","../src/clusterItem.js","../src/utils.js","../src/cluster.js"],"sourcesContent":["/**\r\n * 为点聚合提供画布\r\n * @param options\r\n * {\r\n *   map: 地图,\r\n *   zIndex: 图层zIndex,\r\n *   visible: 是否可见\r\n * }\r\n */\r\nclass Canvas {\r\n  constructor(options) {\r\n    this.layer = null\r\n    this.hoverCanvas = null\r\n    this.hoverCanvasCtx = null\r\n    this.clusterCanvas = null\r\n    this.clusterCanvasCxt = null\r\n    this.options = options\r\n    this._init()\r\n  }\r\n  _init() {\r\n    const {\r\n      options: {\r\n        map,\r\n        visible,\r\n        zIndex\r\n      }\r\n    } = this\r\n    const container = document.createElement('div')\r\n    // 绘制聚合点\r\n    const clusterCanvas = document.createElement('canvas')\r\n    clusterCanvas.style.position = 'absolute'\r\n    // hover状态下的点绘制\r\n    const hoverCanvas = document.createElement('canvas')\r\n    hoverCanvas.style.position = 'absolute'\r\n    container.appendChild(clusterCanvas)\r\n    container.appendChild(hoverCanvas)\r\n    this.clusterCanvas = clusterCanvas\r\n    this.hoverCanvas = hoverCanvas\r\n    this.clusterCanvasCxt = clusterCanvas.getContext('2d')\r\n    this.hoverCanvasCtx = hoverCanvas.getContext('2d')\r\n\r\n    this.layer = new AMap.CustomLayer(container, {\r\n      map,\r\n      zIndex,\r\n      visible,\r\n      zooms: [1, 20]\r\n    })\r\n  }\r\n  // 设备像素比\r\n  getPixelRatio() {\r\n    return Math.min(2, Math.round(window.devicePixelRatio || 1))\r\n  }\r\n  // 设置canvas的width&height属性可以清理画布\r\n  setCanvasSize(canvas, w, h) {\r\n    const pixelRatio = this.getPixelRatio();\r\n    canvas.width = w * pixelRatio;\r\n    canvas.height = h * pixelRatio;\r\n    canvas.style.width = w + 'px';\r\n    canvas.style.height = h + 'px';\r\n  }\r\n  // 清除聚合\r\n  clearCluster() {\r\n    const {\r\n      width,\r\n      height\r\n    } = this.options.map.getSize()\r\n    this.setCanvasSize(this.clusterCanvas, width, height)\r\n  }\r\n}\r\n\r\nexport default Canvas"," class ClusterItem {\r\n  constructor(point, options) {\r\n    this.coordinate = point.coordinate\r\n    this.points = [point]\r\n    this.options = options\r\n  }\r\n  getCount() {\r\n    return this.points.length\r\n  }\r\n  // 更新聚合点的中心点\r\n  updateCenter() {\r\n    const { points, points: { length }, coordinate: { x: centerX, y: centerY }, options: { isAverageCenter } } = this\r\n    if (isAverageCenter) {\r\n      const newAddPoint = points[length - 1]\r\n      const { coordinate: { x: pointX, y: pointY } } = newAddPoint\r\n      const totalX = centerX * (length - 1)\r\n      const totalY = centerY * (length - 1)\r\n      const newCenterX = (totalX + pointX) / length\r\n      const newCenterY = (totalY + pointY) / length\r\n      this.coordinate = {\r\n        x: newCenterX,\r\n        y: newCenterY\r\n      }\r\n    }\r\n  }\r\n  // 往聚合中添加点\r\n  addPoint(point) {\r\n    this.points.push(point)\r\n    this.updateCenter()\r\n  }\r\n  // 判断一个点是否在改聚合范围内\r\n  contains(point) {\r\n    const { coordinate: { x: pointX, y: pointY } } = point\r\n    const { coordinate: { x: centerX, y: centerY }, options: { gridSize } } = this\r\n    return pointX >= centerX - gridSize &&\r\n    pointX <= centerX + gridSize &&\r\n    pointY >= centerY - gridSize &&\r\n    pointY <= centerY + gridSize\r\n  }\r\n}\r\n\r\nexport default ClusterItem","//经纬度转墨卡托\r\nexport function lonLat2Mercator(lonLat) {\r\n  const [longitude, latitude] = lonLat\r\n  let x = (longitude * 20037508.34) / 180\r\n  let y =\r\n    Math.log(Math.tan(((90 + latitude) * Math.PI) / 360)) / (Math.PI / 180)\r\n  y = (y * 20037508.34) / 180\r\n  return {\r\n    x,\r\n    y\r\n  }\r\n}\r\n//墨卡托转经纬度\r\nexport function mercator2LonLat(pixel) {\r\n  const { x, y } = pixel\r\n  let longitude = (x / 20037508.34) * 180\r\n  let latitude = (y / 20037508.34) * 180\r\n  latitude =\r\n    (180 / Math.PI) *\r\n    (2 * Math.atan(Math.exp((latitude * Math.PI) / 180)) - Math.PI / 2)\r\n\r\n  return [longitude, latitude]\r\n}\r\n","import Canvas from './canvas'\r\nimport ClusterItem from './clusterItem'\r\nimport {\r\n  lonLat2Mercator,\r\n  mercator2LonLat\r\n} from './utils'\r\n\r\n// 开发环境输出日志\r\nconst debug = process.env.NODE_ENV === 'development'\r\n\r\n// 聚合策略\r\nexport const ClusterTypes = {\r\n  ZOOM: 'zoom', // 根据缩放层级聚合\r\n  PIXEL: 'pixel' // 根据相对于地图容器的坐标聚合\r\n}\r\n\r\n// 默认的点样式\r\nconst defaultStyle = {\r\n  width: 60,\r\n  height: 69\r\n}\r\n// 聚合默认设置\r\nconst defaultOptions = {\r\n  type: ClusterTypes.PIXEL, // 聚合策略\r\n  maxZoom: 18, // 最大的聚合级别，大于该级别就不进行相应的聚合\r\n  gridSize: 60, // 聚合计算时，网格的像素大小\r\n  minClusterSize: 2, // 聚合的最小数量，小于该数量个点则不能成为一个聚合\r\n  averageCenter: true, // 是否取所有点的平均值作为聚合点中心\r\n  zoomOnClick: true, // 点击聚合点时，是否展开聚合\r\n  zIndex: 120, // canvas图层的zindex\r\n  visible: true, // 是否显示\r\n  getPosition(item) {\r\n    // 获取经纬度信息\r\n    const {\r\n      location\r\n    } = item\r\n    return location ? [location.longitude, location.latitude] : null\r\n  },\r\n  render: null, // 绘制函数\r\n  hoverRender: null, // hover状态下的绘制函数\r\n  // 以下参数主要用于事件系统\r\n  clickHandler: null, // click事件\r\n  mouseoutHandler: null, // mouseout事件\r\n  mouseoverHandler: null, // mouseover事件\r\n  mousemoveHandler: null, // mousemove事件\r\n  normalPointStyle: defaultStyle, // 实体点的样式\r\n  clusterPointStyle: defaultStyle, // 聚合点的样式\r\n  hoverNormalPointStyle: defaultStyle, // hover状态下实体点的样式\r\n  hoverClusterPointStyle: defaultStyle // hover状态下聚合点的样式\r\n}\r\n\r\nclass Cluster {\r\n  constructor(options) {\r\n    const {\r\n      map,\r\n      data\r\n    } = options\r\n    this.options = Object.assign({}, defaultOptions, options)\r\n    this.points = [] // 聚合点+实体点 = 渲染点\r\n    this.buildFn = null // 聚合构建器\r\n    this.pixelFn = null // 还原点坐标到相对地图容器的坐标\r\n    this.lastPixel = {} // 触发事件的坐标\r\n    this.oldHoverPoint = null // 触发事件的对象\r\n    this.renderTimer = null\r\n    this.clusterItems = null\r\n    this.renderEngine = new Canvas({\r\n      map,\r\n      zIndex: this.options.zIndex,\r\n      visible: this.options.visible\r\n    })\r\n    this._init(data)\r\n    this._customEngine()\r\n    this._bindEvent()\r\n  }\r\n  renderLater(delay) {\r\n    if (!this.renderTimer) {\r\n      this.renderTimer = setTimeout(this.render.bind(this), delay || 50)\r\n    }\r\n  }\r\n  render() {\r\n    const {\r\n      points,\r\n      options: {\r\n        render,\r\n        normalPointStyle,\r\n        clusterPointStyle\r\n      },\r\n      renderEngine: {\r\n        clusterCanvasCxt\r\n      }\r\n    } = this\r\n    if (this.renderTimer) {\r\n      clearTimeout(this.renderTimer)\r\n      this.renderTimer = null\r\n    }\r\n    if (debug) {\r\n      console.time('绘制时间：')\r\n    }\r\n    // 清理画布\r\n    this.renderEngine.clearCluster()\r\n    // 绘制\r\n    points.forEach((point) => {\r\n      const pixel = this.pixelFn(point.coordinate)\r\n      const {\r\n        x,\r\n        y\r\n      } = pixel\r\n      const isCluster = this._isCluster(point)\r\n      const style = isCluster ? clusterPointStyle : normalPointStyle\r\n      const {\r\n        width,\r\n        height\r\n      } = style\r\n      // 定位到中心位置\r\n      render(clusterCanvasCxt, x - width / 2, y - height / 2, width, height, {\r\n        isCluster,\r\n        data: point\r\n      })\r\n    })\r\n    if (debug) {\r\n      console.timeEnd('绘制时间：')\r\n    }\r\n  }\r\n  setData(data) {\r\n    this.data = data\r\n    this._buildCluster()\r\n    this.render()\r\n  }\r\n  _init(data) {\r\n    // 根据聚合策略使用不同的聚合构建器\r\n    this._createBuildFn()\r\n    // 把聚合坐标还原为相对于地图容器的坐标\r\n    this._createPixelFn()\r\n    this.setData(data)\r\n  }\r\n  _createBuildFn() {\r\n    const {\r\n      options: {\r\n        map,\r\n        type,\r\n        gridSize,\r\n        averageCenter,\r\n        getPosition\r\n      }\r\n    } = this\r\n    if (type === ClusterTypes.PIXEL) {\r\n      this.buildFn = () => {\r\n        const bounds = map.getBounds()\r\n        const options = {\r\n          gridSize,\r\n          averageCenter\r\n        }\r\n        this.data.forEach((item) => {\r\n          const location = getPosition(item)\r\n          if (location && bounds.contains(location)) {\r\n            // 经纬度转换为相对于地图容器的坐标\r\n            item.coordinate = map.lngLatToContainer(location)\r\n            this._buildClusterItem(item, options)\r\n          }\r\n        })\r\n      }\r\n    } else {\r\n      this.buildFn = () => {\r\n        const zoom = map.getZoom()\r\n        const bounds = this._getExtendedBounds()\r\n        const options = {\r\n          averageCenter,\r\n          gridSize: gridSize * Math.pow(2, 18 - zoom)\r\n        }\r\n        this.data.forEach((item) => {\r\n          const location = getPosition(item)\r\n          // 反转经纬度的时候使用\r\n          if (location) {\r\n            // 经纬度转换为墨卡托坐标\r\n            if (!item.coordinate) {\r\n              item.coordinate = lonLat2Mercator(location)\r\n            }\r\n            if (this._pointInScreen(bounds, item.coordinate)) {\r\n              this._buildClusterItem(item, options)\r\n            }\r\n          }\r\n        })\r\n      }\r\n    }\r\n  }\r\n  _createPixelFn() {\r\n    const {\r\n      options: {\r\n        type,\r\n        map\r\n      }\r\n    } = this\r\n    if (type === ClusterTypes.PIXEL) {\r\n      this.pixelFn = (coordinate) => coordinate\r\n    } else {\r\n      this.pixelFn = (coordinate) => {\r\n        // 墨卡托坐标=>经纬度\r\n        const lnglat = mercator2LonLat(coordinate)\r\n        // 经纬度=>相对地图容器的坐标\r\n        return map.lngLatToContainer(lnglat)\r\n      }\r\n    }\r\n  }\r\n  _buildCluster() {\r\n    if (debug) {\r\n      console.time('聚合构建时间：')\r\n    }\r\n    this.clusterItems = []\r\n    if (this.data) {\r\n      this.buildFn()\r\n      this._updatePoints()\r\n      this.render()\r\n    }\r\n    if (debug) {\r\n      console.timeEnd('聚合构建时间：')\r\n      console.log('%c构建聚合模块数量：' + this.points.length, 'color: red')\r\n    }\r\n  }\r\n  _buildClusterItem(point, options) {\r\n    let parent = null\r\n    let distance = -1 // 当前点与聚合中心的距离\r\n    const {\r\n      coordinate: {\r\n        x: pointX,\r\n        y: pointY\r\n      }\r\n    } = point\r\n    this.clusterItems.forEach((clusterItem) => {\r\n      if (clusterItem.contains(point)) {\r\n        const {\r\n          coordinate: {\r\n            x: centerX,\r\n            y: centerY\r\n          }\r\n        } = clusterItem\r\n        const currDistance =\r\n          Math.pow(pointX - centerX, 2) + Math.pow(pointY - centerY, 2)\r\n        if (distance < 0 || distance > currDistance) {\r\n          // 取距离最近的一个聚合\r\n          parent = clusterItem\r\n          distance = currDistance\r\n        }\r\n      }\r\n    })\r\n    if (parent) {\r\n      // 该点找到聚合对象\r\n      parent.addPoint(point)\r\n    } else {\r\n      // 以该点为中心创建一个聚合对象\r\n      const clusterItem = new ClusterItem(point, options)\r\n      this.clusterItems.push(clusterItem)\r\n    }\r\n  }\r\n  _updatePoints() {\r\n    const {\r\n      clusterItems,\r\n      options: {\r\n        map,\r\n        minClusterSize,\r\n        maxZoom\r\n      }\r\n    } = this\r\n    if (map.getZoom() >= maxZoom) {\r\n      // 地图放大最大层级，就不存在聚合点了\r\n      this.points = clusterItems.reduce(\r\n        (pre, curr) => pre.concat(curr.points), []\r\n      )\r\n    } else {\r\n      // 返回的点数据应该是聚合点+实体点\r\n      let points = []\r\n      clusterItems.forEach((clusterItem) => {\r\n        if (clusterItem.getCount() >= minClusterSize) {\r\n          // 聚合点\r\n          points.push(clusterItem)\r\n        } else {\r\n          // 实体点\r\n          points = points.concat(clusterItem.points)\r\n        }\r\n      })\r\n      this.points = points\r\n    }\r\n  }\r\n  _customEngine() {\r\n    // 重要：当图层发生变动时，自动调用render函数\r\n    this.renderEngine.layer.render = this._buildCluster.bind(this)\r\n  }\r\n  _bindEvent() {\r\n    const {\r\n      options: {\r\n        map\r\n      }\r\n    } = this\r\n    // 更新视图\r\n    // map.on('moveend', this._buildCluster.bind(this))\r\n    // map.on('zoomchange', this._buildCluster.bind(this))\r\n    // 实现canvas事件\r\n    map.on('click', this._clickHandler.bind(this)) // => point click 事件\r\n    map.on('mousemove', this._mousemoveHandler.bind(this)) // => point hover 事件\r\n  }\r\n  _clickHandler(event) {\r\n    const {\r\n      pixel\r\n    } = event\r\n    const point = this._findEventPoint(pixel)\r\n    if (point) {\r\n      const {\r\n        options: {\r\n          zoomOnClick,\r\n          clickHandler\r\n        }\r\n      } = this\r\n      const params = {\r\n        data: point,\r\n        isCluster: this._isCluster(point)\r\n      }\r\n      // 触发 `mouseout`\r\n      this.mouseoutHandler()\r\n      // 点击聚合点展开聚合\r\n      zoomOnClick && this._zoomOnClickHandler(params)\r\n      this._isFunction(clickHandler) && clickHandler(params)\r\n    }\r\n  }\r\n  // 由`mousemove`衍生出 `mouseout` & `mouseover`\r\n  _mousemoveHandler(event) {\r\n    const {\r\n      pixel\r\n    } = event\r\n    const {\r\n      lastPixel,\r\n      oldHoverPoint\r\n    } = this\r\n    if (lastPixel.x === pixel.x && lastPixel.y === pixel.y) {\r\n      return\r\n    }\r\n    const point = this._findEventPoint(pixel)\r\n    if (point === oldHoverPoint) {\r\n      return\r\n    }\r\n    this.mouseoutHandler(point)\r\n    this.mouseoverHandler(point)\r\n    this.lastPixel = pixel\r\n  }\r\n  mouseoutHandler(point) {\r\n    const {\r\n      oldHoverPoint,\r\n      options: {\r\n        mouseoutHandler\r\n      }\r\n    } = this\r\n    if (oldHoverPoint) {\r\n      this._clearHoverPoint()\r\n      this._isFunction(mouseoutHandler) &&\r\n        mouseoutHandler({\r\n          data: oldHoverPoint,\r\n          isCluster: this._isCluster(oldHoverPoint)\r\n        })\r\n    }\r\n    this.oldHoverPoint = point\r\n  }\r\n  mouseoverHandler(point) {\r\n    if (!point) {\r\n      return\r\n    }\r\n    const {\r\n      options: {\r\n        mouseoverHandler\r\n      }\r\n    } = this\r\n    const params = {\r\n      data: point,\r\n      isCluster: this._isCluster(point)\r\n    }\r\n    this._drawHoverPoint(params)\r\n    this._isFunction(mouseoverHandler) && mouseoverHandler(params)\r\n  }\r\n  _zoomOnClickHandler(data) {\r\n    const {\r\n      isCluster,\r\n      data: {\r\n        coordinate\r\n      }\r\n    } = data\r\n    if (isCluster) {\r\n      const {\r\n        options: {\r\n          map\r\n        },\r\n        pixelFn\r\n      } = this\r\n      const pixel = pixelFn(coordinate)\r\n      const lnglat = map.containerToLngLat(pixel)\r\n      map.setCenter(lnglat)\r\n      map.zoomIn()\r\n    }\r\n  }\r\n  _drawHoverPoint(params) {\r\n    const {\r\n      options: {\r\n        hoverRender,\r\n        normalPointStyle,\r\n        clusterPointStyle\r\n      },\r\n      renderEngine,\r\n      renderEngine: {\r\n        hoverCanvas,\r\n        hoverCanvasCtx\r\n      }\r\n    } = this\r\n    if (this._isFunction(hoverRender)) {\r\n      const margin = 20\r\n      const {\r\n        isCluster,\r\n        data: {\r\n          coordinate: {\r\n            x,\r\n            y\r\n          }\r\n        }\r\n      } = params\r\n      const style = isCluster ? clusterPointStyle : normalPointStyle\r\n      const {\r\n        width,\r\n        height\r\n      } = style\r\n      const canvasWidth = width + margin\r\n      const canvasHeight = height + margin\r\n      const canvasLeft = x - canvasWidth / 2\r\n      const canvasTop = y - canvasHeight / 2\r\n      const pixelRatio = renderEngine.getPixelRatio()\r\n      hoverCanvas.style.left = canvasLeft + 'px'\r\n      hoverCanvas.style.top = canvasTop + 'px'\r\n      hoverCanvas.style.cursor = 'pointer'\r\n      renderEngine.setCanvasSize(hoverCanvas, canvasWidth, canvasHeight)\r\n      hoverCanvasCtx.save()\r\n      hoverCanvasCtx.translate(-canvasLeft * pixelRatio, -canvasTop * pixelRatio)\r\n      hoverRender(\r\n        hoverCanvasCtx,\r\n        canvasLeft + margin / 2,\r\n        canvasTop + margin / 2,\r\n        width,\r\n        height,\r\n        params\r\n      )\r\n      hoverCanvasCtx.restore()\r\n    }\r\n  }\r\n  _clearHoverPoint() {\r\n    const {\r\n      renderEngine,\r\n      renderEngine: {\r\n        hoverCanvas\r\n      }\r\n    } = this\r\n    renderEngine.setCanvasSize(hoverCanvas, 0, 0)\r\n  }\r\n  _findEventPoint(mousePoint) {\r\n    // 查找鼠标下面的点，因为聚合点跟实体点的大小可能不一致，所以要分开查找\r\n    const {\r\n      points,\r\n      _constains,\r\n      options: {\r\n        normalPointStyle,\r\n        clusterPointStyle\r\n      }\r\n    } = this\r\n    const _clusterPoints = []\r\n    const _normalPoints = []\r\n    points.forEach((item) => {\r\n      if (this._isCluster(item)) {\r\n        _clusterPoints.push(item)\r\n      } else {\r\n        _normalPoints.push(item)\r\n      }\r\n    })\r\n    for (let i = 0, len1 = _clusterPoints.length; i < len1; i++) {\r\n      const item = _clusterPoints[i]\r\n      if (_constains(item.coordinate, mousePoint, clusterPointStyle)) {\r\n        return item\r\n      }\r\n    }\r\n    for (let k = 0, len2 = _normalPoints.length; k < len2; k++) {\r\n      const item = _normalPoints[k]\r\n      if (_constains(item.coordinate, mousePoint, normalPointStyle)) {\r\n        return item\r\n      }\r\n    }\r\n    return null\r\n  }\r\n  _constains(p1, p2, style) {\r\n    // 绘画的时候是以 `p1` 作为中心点\r\n    const {\r\n      width,\r\n      height\r\n    } = style\r\n    const {\r\n      x: x1,\r\n      y: y1\r\n    } = p1\r\n    const {\r\n      x: x2,\r\n      y: y2\r\n    } = p2\r\n    return (\r\n      x2 >= x1 - width / 2 &&\r\n      x2 <= x1 + width / 2 &&\r\n      y2 >= y1 - height / 2 &&\r\n      y2 <= y1 + height / 2\r\n    )\r\n  }\r\n  _getExtendedBounds() {\r\n    const {\r\n      options: {\r\n        map,\r\n        gridSize\r\n      }\r\n    } = this\r\n    const zoom = map.getZoom()\r\n    const bounds = map.getBounds()\r\n    const southWest = bounds.getSouthWest()\r\n    const northEast = bounds.getNorthEast()\r\n    // 上右\r\n    const tr = lonLat2Mercator([southWest.lng, southWest.lat])\r\n    // 下左\r\n    const bl = lonLat2Mercator([northEast.lng, northEast.lat])\r\n    const _gridSize = gridSize * Math.pow(2, 18 - zoom)\r\n    tr.x -= _gridSize\r\n    tr.y -= _gridSize\r\n    bl.x += _gridSize\r\n    bl.y += _gridSize\r\n    return [tr, bl]\r\n  }\r\n  _pointInScreen(bounds, coordinate) {\r\n    const [tr, bl] = bounds\r\n    const {\r\n      x,\r\n      y\r\n    } = coordinate\r\n    return bl.x <= 0 || x >= tr.x && x <= bl.x && y >= tr.y && y <= bl.y\r\n  }\r\n  _isFunction(fn) {\r\n    return typeof fn === 'function'\r\n  }\r\n  _isCluster(point) {\r\n    return point instanceof ClusterItem\r\n  }\r\n}\r\n\r\nexport default Cluster"],"names":["Canvas","options","layer","hoverCanvas","hoverCanvasCtx","clusterCanvas","clusterCanvasCxt","_init","this","map","visible","zIndex","container","document","createElement","style","position","appendChild","getContext","AMap","CustomLayer","Math","min","round","window","devicePixelRatio","canvas","w","h","pixelRatio","getPixelRatio","width","height","getSize","setCanvasSize","ClusterItem","point","coordinate","points","length","centerX","x","centerY","y","isAverageCenter","newCenterX","newCenterY","push","updateCenter","pointX","pointY","gridSize","lonLat2Mercator","lonLat","longitude","latitude","log","tan","PI","mercator2LonLat","pixel","atan","exp","ClusterTypes","defaultStyle","defaultOptions","PIXEL","item","location","Cluster","data","Object","assign","buildFn","pixelFn","lastPixel","oldHoverPoint","renderTimer","clusterItems","renderEngine","_customEngine","_bindEvent","delay","setTimeout","render","bind","normalPointStyle","clusterPointStyle","clearCluster","forEach","_this","isCluster","_isCluster","_buildCluster","_createBuildFn","_createPixelFn","setData","type","averageCenter","getPosition","bounds","getBounds","contains","lngLatToContainer","_buildClusterItem","zoom","getZoom","_this2","_getExtendedBounds","pow","_pointInScreen","lnglat","_updatePoints","parent","distance","clusterItem","currDistance","addPoint","minClusterSize","maxZoom","reduce","pre","curr","concat","getCount","on","_clickHandler","_mousemoveHandler","event","_findEventPoint","zoomOnClick","clickHandler","params","mouseoutHandler","_zoomOnClickHandler","_isFunction","mouseoverHandler","_clearHoverPoint","_drawHoverPoint","containerToLngLat","setCenter","zoomIn","hoverRender","canvasWidth","canvasHeight","canvasLeft","canvasTop","left","top","cursor","save","translate","margin","restore","mousePoint","_constains","_clusterPoints","_normalPoints","_this3","i","len1","k","len2","p1","p2","x1","y1","x2","y2","southWest","getSouthWest","northEast","getNorthEast","tr","lng","lat","bl","_gridSize","fn"],"mappings":"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"}