{"version":3,"file":"amap-cluster-canvas.umd.js","sources":["../src/canvas.js","../src/clusterItem.js","../src/amap.coordinate.js","../src/utils.js","../src/mercator.coordinate.js","../src/event.js","../src/cluster.js"],"sourcesContent":["/**\r\n * 为点聚合提供画布\r\n * @param options\r\n * {\r\n *   map: 地图,\r\n *   zIndex: 图层zIndex,\r\n *   visible: 是否可见\r\n * }\r\n */\r\nclass Canvas {\r\n  constructor( options ) {\r\n    this.layer = null\r\n    this.hoverCanvas = null\r\n    this.hoverCanvasCtx = null\r\n    this.clusterCanvas = null\r\n    this.clusterCanvasCxt = null\r\n    this.options = options\r\n    this.pixelRatio = this.getPixelRatio()\r\n    this.init()\r\n  }\r\n  init() {\r\n    const {\r\n      options: { map, visible, zIndex, render }\r\n    } = this\r\n    const container = document.createElement( 'div' )\r\n    // 绘制聚合点\r\n    const clusterCanvas = document.createElement( 'canvas' )\r\n    clusterCanvas.style.position = 'absolute'\r\n    // hover状态下的点绘制\r\n    const hoverCanvas = document.createElement( 'canvas' )\r\n    hoverCanvas.style.position = 'absolute'\r\n    container.appendChild( clusterCanvas )\r\n    container.appendChild( hoverCanvas )\r\n    this.clusterCanvas = clusterCanvas\r\n    this.hoverCanvas = hoverCanvas\r\n    this.clusterCanvasCxt = clusterCanvas.getContext( '2d' )\r\n    this.hoverCanvasCtx = hoverCanvas.getContext( '2d' )\r\n\r\n    this.layer = new AMap.CustomLayer( container, {\r\n      map,\r\n      zIndex,\r\n      visible,\r\n      zooms: [1, 20]\r\n    } )\r\n    this.layer.render = render\r\n  }\r\n  // 设备像素比\r\n  getPixelRatio() {\r\n    return Math.min( 2, Math.round( window.devicePixelRatio || 1 ) )\r\n  }\r\n  // 设置canvas的width&height属性可以清理画布\r\n  setCanvasSize( canvas, w, h ) {\r\n    const { pixelRatio } = this\r\n    canvas.width = w * pixelRatio\r\n    canvas.height = h * pixelRatio\r\n    canvas.style.width = w + 'px'\r\n    canvas.style.height = h + 'px'\r\n  }\r\n}\r\n\r\nexport default Canvas\r\n","class ClusterItem {\r\n  constructor( point, options ) {\r\n    this.renderPixel = null\r\n    this.points = [point]\r\n    this.coordinate = point.coordinate\r\n    this.averageCenter = options.averageCenter\r\n    this.coordinateEngine = options.coordinateEngine\r\n  }\r\n  getCount() {\r\n    return this.points.length\r\n  }\r\n  // 更新聚合点的中心点\r\n  updateCenter() {\r\n    const {\r\n      averageCenter,\r\n      points,\r\n      points: { length },\r\n      coordinate: { x: centerX, y: centerY }\r\n    } = this\r\n    if ( averageCenter ) {\r\n      const newAddPoint = points[length - 1]\r\n      const {\r\n        coordinate: { x: pointX, y: pointY }\r\n      } = newAddPoint\r\n      const totalX = centerX * ( length - 1 )\r\n      const totalY = centerY * ( length - 1 )\r\n      const newCenterX = ( totalX + pointX ) / length\r\n      const newCenterY = ( totalY + pointY ) / length\r\n      this.coordinate = {\r\n        x: newCenterX,\r\n        y: newCenterY\r\n      }\r\n      this.renderPixel = this.coordinateEngine.coordinateToPixel( this )\r\n    } else {\r\n      const centerPoint = this.points[0]\r\n      this.coordinate = centerPoint.coordinate\r\n      this.renderPixel = centerPoint.renderPixel\r\n    }\r\n  }\r\n  // 往聚合中添加点\r\n  addPoint( point ) {\r\n    this.points.push( point )\r\n    this.updateCenter()\r\n  }\r\n  // 判断一个点是否在改聚合范围内\r\n  contains( point ) {\r\n    const {\r\n      coordinate: { x: pointX, y: pointY }\r\n    } = point\r\n    const {\r\n      coordinate: { x: centerX, y: centerY }\r\n    } = this\r\n    const gridSize = this.coordinateEngine.getGridSize()\r\n    return (\r\n      pointX >= centerX - gridSize &&\r\n      pointX <= centerX + gridSize &&\r\n      pointY >= centerY - gridSize &&\r\n      pointY <= centerY + gridSize\r\n    )\r\n  }\r\n}\r\n\r\nexport default ClusterItem\r\n","export default class AmapCoordinate {\r\n  constructor( options ) {\r\n    this.map = options.map\r\n    this.gridSize = options.gridSize\r\n  }\r\n  getGridSize() {\r\n    return this.gridSize\r\n  }\r\n  getRenderData( data ) {\r\n    const renderData = []\r\n    const bounds = this.map.getBounds()\r\n    data.forEach( item => {\r\n      if ( bounds.contains( item.position ) ) {\r\n        // 经纬度转换为相对于地图容器的坐标\r\n        const coordinate = this.map.lngLatToContainer( item.position )\r\n        renderData.push( {\r\n          ...item,\r\n          coordinate,\r\n          renderPixel: coordinate\r\n        } )\r\n      }\r\n    } )\r\n    return renderData\r\n  }\r\n  coordinateToPixel( point ) {\r\n    return point.coordinate\r\n  }\r\n}\r\n","// 经纬度转墨卡托\r\nexport function lonLat2Mercator( lonLat ) {\r\n  const [longitude, latitude] = lonLat\r\n  let x = ( longitude * 20037508.34 ) / 180\r\n  let y =\r\n    Math.log( Math.tan( ( ( 90 + latitude ) * Math.PI ) / 360 ) ) / ( Math.PI / 180 )\r\n  y = ( y * 20037508.34 ) / 180\r\n  return {\r\n    x,\r\n    y\r\n  }\r\n}\r\n// 墨卡托转经纬度\r\nexport function mercator2LonLat( pixel ) {\r\n  const { x, y } = pixel\r\n  let longitude = ( x / 20037508.34 ) * 180\r\n  let latitude = ( y / 20037508.34 ) * 180\r\n  latitude =\r\n    ( 180 / Math.PI ) *\r\n    ( 2 * Math.atan( Math.exp( ( latitude * Math.PI ) / 180 ) ) - Math.PI / 2 )\r\n\r\n  return [longitude, latitude]\r\n}\r\n/**\r\n * 获取 offset 的值\r\n * @param {number} value\r\n * @param {any} offset\r\n * 1. offset 纯数字\r\n * 2. offset 百分比\r\n * 3. 默认返回 Number.parseFloat 的值\r\n */\r\nfunction getOffsetValue( value, offset ) {\r\n  const type = typeof offset\r\n  switch ( type ) {\r\n    case 'number':\r\n      return offset\r\n    case 'string':\r\n      const _offset = offset.trim()\r\n      if ( _offset.substr( -1 ) === '%' ) {\r\n        return value * ( Number.parseFloat( offset ) / 100 )\r\n      }\r\n      return Number.parseFloat( offset )\r\n    default:\r\n      return Number.parseFloat( offset )\r\n  }\r\n}\r\n// 解析 offset 参数\r\nexport function getOffset( style, offset ) {\r\n  if ( !Array.isArray( offset ) ) {\r\n    return [0, 0]\r\n  }\r\n  const { width, height } = style\r\n  return [getOffsetValue( width, offset[0] ), getOffsetValue( height, offset[1] )]\r\n}\r\n","import { lonLat2Mercator, mercator2LonLat } from './utils'\r\n\r\nexport default class MercatorCoordinate {\r\n  constructor( options ) {\r\n    this.map = options.map\r\n    this.gridSize = options.gridSize\r\n  }\r\n  getGridSize() {\r\n    return this.gridSize * Math.pow( 2, 18 - this.map.getZoom() )\r\n  }\r\n  getRenderData( data ) {\r\n    const renderData = []\r\n    const bounds = this.getExtendedBounds()\r\n    data.forEach( item => {\r\n      let { coordinate, renderPixel } = item\r\n      if ( !coordinate ) {\r\n        coordinate = lonLat2Mercator( item.position )\r\n        renderPixel = this.coordinateToPixel( item )\r\n      }\r\n      if ( this.contains( bounds, coordinate ) ) {\r\n        renderData.push( {\r\n          ...item,\r\n          coordinate,\r\n          renderPixel\r\n        } )\r\n      }\r\n    } )\r\n    return renderData\r\n  }\r\n  getExtendedBounds() {\r\n    const gridSize = this.getGridSize()\r\n    const bounds = this.map.getBounds()\r\n    const southWest = bounds.getSouthWest()\r\n    const northEast = bounds.getNorthEast()\r\n    // 上右\r\n    const tr = lonLat2Mercator( [southWest.lng, southWest.lat] )\r\n    // 下左\r\n    const bl = lonLat2Mercator( [northEast.lng, northEast.lat] )\r\n    tr.x -= gridSize\r\n    tr.y -= gridSize\r\n    bl.x += gridSize\r\n    bl.y += gridSize\r\n    return [tr, bl]\r\n  }\r\n  coordinateToPixel( point ) {\r\n    return this.map.lngLatToContainer(\r\n      point.position || mercator2LonLat( point.coordinate )\r\n    )\r\n  }\r\n  contains( bounds, coordinate ) {\r\n    const [tr, bl] = bounds\r\n    const { x, y } = coordinate\r\n    // 小于等于0 ：地图缩放到最小，世界地图都在视图内\r\n    return bl.x <= 0 || ( x >= tr.x && x <= bl.x && y >= tr.y && y <= bl.y )\r\n  }\r\n}\r\n","export default class Event {\r\n  constructor(cluster) {\r\n    this.hoverPoint = null\r\n    this.cluster = cluster\r\n    this.map = cluster.options.map\r\n    this.click = cluster.options.clickHandler\r\n    this.mouseout = cluster.options.mouseoutHandler\r\n    this.mouseover = cluster.options.mouseoverHandler\r\n    this.mousemove = cluster.options.mousemoveHandler\r\n    this.zoomOnClick = cluster.options.zoomOnClick\r\n    this.clickHandler = this.clickHandler.bind(this)\r\n    this.mousemoveHandler = this.mousemoveHandler.bind(this)\r\n    this.zoomstartHandler = this.zoomstartHandler.bind(this)\r\n    this.initEvent()\r\n  }\r\n  initEvent() {\r\n    this.map.on('click', this.clickHandler)\r\n    this.map.on('mousemove', this.mousemoveHandler)\r\n    this.map.on('zoomstart', this.zoomstartHandler)\r\n  }\r\n  off() {\r\n    this.map.off('click', this.clickHandler)\r\n    this.map.off('mousemove', this.mousemoveHandler)\r\n    this.map.off('zoomstart', this.zoomstartHandler)\r\n  }\r\n  clickHandler(event) {\r\n    const {pixel} = event\r\n    const point = this.findPoint(pixel)\r\n    if (point) {\r\n      const params = this.cluster.getParams(point)\r\n      // 触发 `mouseout`\r\n      this.mouseoutHandler(point)\r\n      // 点击聚合点展开聚合\r\n      this.zoomOnClick && params.isCluster && this.zoomOnClickHandler(point)\r\n      this.cluster.isFunction(this.click) && this.click(params)\r\n    }\r\n  }\r\n  // 由`mousemove`衍生出 `mouseout` & `mouseover`\r\n  mousemoveHandler(event) {\r\n    const {pixel} = event\r\n    const hoverPoint = this.hoverPoint\r\n    const point = this.findPoint(pixel)\r\n    // 先触发 mouseout 事件\r\n    if (hoverPoint && !this.constains(hoverPoint, pixel)) {\r\n      this.mouseoutHandler()\r\n    }\r\n    // 后触发 mouseover 事件\r\n    if (point && hoverPoint !== point) {\r\n      this.mouseoverHandler(point)\r\n    }\r\n    this.cluster.isFunction(this.mousemove) && this.mousemove(event, point)\r\n  }\r\n  mouseoverHandler(point) {\r\n    this.hoverPoint = point\r\n    const params = this.cluster.getParams(point)\r\n    this.cluster.renderHoverPoint(params)\r\n    this.cluster.isFunction(this.mouseover) && this.mouseover(params)\r\n  }\r\n  mouseoutHandler() {\r\n    this.hoverPoint = null\r\n    this.cluster.clearHoverPoint()\r\n    this.cluster.isFunction(this.mouseout) &&\r\n      this.mouseout(this.cluster.getParams(this.hoverPoint))\r\n  }\r\n  zoomstartHandler() {\r\n    this.mouseoutHandler()\r\n  }\r\n  zoomOnClickHandler(point) {\r\n    const {\r\n      renderPixel: {x, y},\r\n    } = point\r\n    const pixel = new AMap.Pixel(x, y)\r\n    const lnglat = this.map.containerToLngLat(pixel)\r\n    this.map.setCenter(lnglat)\r\n    this.map.zoomIn()\r\n  }\r\n  // 查找鼠标下面的点，因为聚合点跟实体点的大小可能不一致，所以要分开查找\r\n  findPoint(eventPixel) {\r\n    const data = this.cluster.getPoints()\r\n    const {length} = data\r\n    for (let i = 0; i < length; i++) {\r\n      const point = data[i]\r\n      if (this.constains(point, eventPixel)) {\r\n        return point\r\n      }\r\n    }\r\n    return null\r\n  }\r\n  // pixel 坐标是否在 point 范围内\r\n  constains(point, pixel) {\r\n    const params = this.cluster.getParams(point)\r\n    const {\r\n      offset: [offsetX, offsetY],\r\n      style: {width, height},\r\n    } = params\r\n    const {\r\n      renderPixel: {x: x1, y: y1},\r\n    } = point\r\n    const {x: x2, y: y2} = pixel\r\n    return (\r\n      x2 >= x1 + offsetX &&\r\n      x2 <= x1 + width + offsetX &&\r\n      y2 >= y1 + offsetY &&\r\n      y2 <= y1 + height + offsetY\r\n    )\r\n  }\r\n}\r\n","import Canvas from './canvas'\r\nimport ClusterItem from './clusterItem'\r\nimport AmapCoordinate from './amap.coordinate'\r\nimport MercatorCoordinate from './mercator.coordinate'\r\nimport Event from './event'\r\nimport {getOffset} from './utils'\r\n\r\n// 开发环境输出日志\r\nconst debug = process.env.NODE_ENV === 'development'\r\n\r\n// 聚合策略\r\nexport const Coordinate = {\r\n  MERCATOR: 'MERCATOR', // 使用 墨卡托 坐标系\r\n  AMAP: 'AMAP', // 使用高德地图容器的相对坐标\r\n}\r\n\r\n// 默认的点样式\r\nconst defaultStyle = {\r\n  width: 60,\r\n  height: 69,\r\n}\r\n// 聚合默认设置\r\nconst defaultOptions = {\r\n  data: null, // 数据集\r\n  coordinate: Coordinate.AMAP, // 聚合策略\r\n  maxZoom: 18, // 最大的聚合级别，大于该级别就不进行相应的聚合\r\n  gridSize: 60, // 聚合计算时，网格的像素大小\r\n  minClusterSize: 2, // 聚合的最小数量，小于该数量个点则不能成为一个聚合\r\n  averageCenter: true, // 是否取所有点的平均值作为聚合点中心\r\n  zoomOnClick: true, // 点击聚合点时，是否展开聚合\r\n  zIndex: 120, // canvas图层的zindex\r\n  visible: true, // 是否显示\r\n  offset: null, // 绘制图形相对于定位点的偏移度\r\n  getPosition(item) {\r\n    // 获取经纬度信息\r\n    const {location} = item\r\n    const {longitude, latitude} = location || {}\r\n    return longitude && latitude ? [longitude, latitude] : null\r\n  },\r\n  render: null, // 绘制函数\r\n  hoverRender: null, // hover状态下的绘制函数\r\n  // 以下参数主要用于事件系统\r\n  clickHandler: null, // click事件\r\n  mouseoutHandler: null, // mouseout事件\r\n  mouseoverHandler: null, // mouseover事件\r\n  mousemoveHandler: null, // mousemove事件\r\n  normalPointStyle: defaultStyle, // 实体点的样式\r\n  clusterPointStyle: defaultStyle, // 聚合点的样式\r\n  hoverNormalPointStyle: defaultStyle, // hover状态下实体点的样式\r\n  hoverClusterPointStyle: defaultStyle, // hover状态下聚合点的样式\r\n}\r\n\r\nexport default class Cluster {\r\n  constructor(options) {\r\n    this.data = null\r\n    this.points = []\r\n    this.renderData = null\r\n    this.clusterItems = null\r\n    this.options = Object.assign({}, defaultOptions, options)\r\n    // 解除 data 引用\r\n    this.options.data = null\r\n    this.normalOffset = getOffset(this.options.normalPointStyle, options.offset)\r\n    this.clusterOffset = getOffset(\r\n      this.options.clusterPointStyle,\r\n      options.offset\r\n    )\r\n    this.eventEngine = new Event(this)\r\n    this.renderEngine = new Canvas({\r\n      map: this.options.map,\r\n      zIndex: this.options.zIndex,\r\n      visible: this.options.visible,\r\n      render: this.build.bind(this),\r\n    })\r\n    this.coordinateEngine =\r\n      this.options.coordinate === Coordinate.AMAP\r\n        ? new AmapCoordinate(this.options)\r\n        : new MercatorCoordinate(this.options)\r\n    this.setData(options.data, false)\r\n  }\r\n  setData(data, rebuild = true) {\r\n    const {\r\n      options: {getPosition},\r\n    } = this\r\n    this.data = []\r\n    if (data) {\r\n      data.forEach(item => {\r\n        const position = getPosition(item)\r\n        if (position) {\r\n          item.position = position\r\n          this.data.push(item)\r\n        }\r\n      })\r\n    }\r\n    if (rebuild) {\r\n      this.build()\r\n    }\r\n  }\r\n  build() {\r\n    if (debug) {\r\n      console.time('聚合构建时间：')\r\n    }\r\n    this.buildCusterItem()\r\n    this.updatePoints()\r\n    this.render()\r\n    if (debug) {\r\n      console.timeEnd('聚合构建时间：')\r\n      console.log('%c构建聚合模块数量：' + this.points.length, 'color: red')\r\n    }\r\n  }\r\n  buildCusterItem() {\r\n    const options = {\r\n      coordinateEngine: this.coordinateEngine,\r\n      averageCenter: this.options.averageCenter,\r\n    }\r\n    this.clusterItems = []\r\n    this.renderData = this.coordinateEngine.getRenderData(this.data)\r\n    this.renderData.forEach(point => {\r\n      let parent = null\r\n      let distance = -1 // 当前点与聚合中心的距离\r\n      const {\r\n        coordinate: {x: pointX, y: pointY},\r\n      } = point\r\n      this.clusterItems.forEach(clusterItem => {\r\n        if (clusterItem.contains(point)) {\r\n          const {\r\n            coordinate: {x: centerX, y: centerY},\r\n          } = clusterItem\r\n          const currDistance =\r\n            Math.pow(pointX - centerX, 2) + Math.pow(pointY - centerY, 2)\r\n          if (distance < 0 || distance > currDistance) {\r\n            // 取距离最近的一个聚合\r\n            parent = clusterItem\r\n            distance = currDistance\r\n          }\r\n        }\r\n      })\r\n      if (parent) {\r\n        // 该点找到聚合对象\r\n        parent.addPoint(point)\r\n      } else {\r\n        // 以该点为中心创建一个聚合对象\r\n        const clusterItem = new ClusterItem(point, options)\r\n        this.clusterItems.push(clusterItem)\r\n      }\r\n    })\r\n  }\r\n  updatePoints() {\r\n    const {\r\n      clusterItems,\r\n      options: {map, minClusterSize, maxZoom},\r\n    } = this\r\n    if (map.getZoom() >= maxZoom) {\r\n      // 地图放大最大层级，就不存在聚合点了\r\n      this.points = clusterItems.reduce(\r\n        (pre, curr) => pre.concat(curr.points),\r\n        []\r\n      )\r\n    } else {\r\n      // 返回的点数据应该是聚合点+实体点\r\n      let points = []\r\n      clusterItems.forEach(clusterItem => {\r\n        if (clusterItem.getCount() >= minClusterSize) {\r\n          // 聚合点\r\n          points.push(clusterItem)\r\n        } else {\r\n          // 实体点\r\n          points = points.concat(clusterItem.points)\r\n        }\r\n      })\r\n      this.points = points\r\n    }\r\n  }\r\n  renderLater(delay) {\r\n    if (!this.renderTimer) {\r\n      this.renderTimer = setTimeout(this.render.bind(this), delay || 50)\r\n    }\r\n  }\r\n  render() {\r\n    const {\r\n      points,\r\n      options: {render},\r\n      renderEngine: {pixelRatio, clusterCanvasCxt},\r\n    } = this\r\n    if (!this.isFunction(render)) {\r\n      return\r\n    }\r\n    if (this.renderTimer) {\r\n      clearTimeout(this.renderTimer)\r\n      this.renderTimer = null\r\n    }\r\n    if (debug) {\r\n      console.time('绘制时间：')\r\n    }\r\n    // 清理画布\r\n    this.clearCluster()\r\n    // 绘制\r\n    points.forEach((point, index) => {\r\n      const params = this.getParams(point)\r\n      params.index = index\r\n      // 定位到中心位置\r\n      render(\r\n        clusterCanvasCxt,\r\n        point.renderPixel.x * pixelRatio,\r\n        point.renderPixel.y * pixelRatio,\r\n        params.style.width,\r\n        params.style.height,\r\n        params,\r\n        points\r\n      )\r\n    })\r\n    if (debug) {\r\n      console.timeEnd('绘制时间：')\r\n    }\r\n  }\r\n  renderHoverPoint(params) {\r\n    if (this.isFunction(this.options.hoverRender)) {\r\n      const {\r\n        isCluster,\r\n        data: {\r\n          renderPixel: {x, y},\r\n        },\r\n      } = params\r\n      const {\r\n        renderEngine,\r\n        renderEngine: {hoverCanvasCtx},\r\n        options: {hoverRender, hoverNormalPointStyle, hoverClusterPointStyle},\r\n      } = this\r\n      const style = isCluster ? hoverClusterPointStyle : hoverNormalPointStyle\r\n      const {width, height} = style\r\n      const pixelRatio = renderEngine.getPixelRatio()\r\n      const canvasLeft = x * pixelRatio\r\n      const canvasTop = y * pixelRatio\r\n      hoverRender(hoverCanvasCtx, canvasLeft, canvasTop, width, height, params)\r\n    }\r\n  }\r\n  // 清除聚合\r\n  clearCluster() {\r\n    const {\r\n      renderEngine,\r\n      renderEngine: {clusterCanvas},\r\n      options: {map},\r\n    } = this\r\n    const {width, height} = map.getSize()\r\n    renderEngine.setCanvasSize(clusterCanvas, width, height)\r\n  }\r\n  // 清除 hover 点\r\n  clearHoverPoint() {\r\n    const {\r\n      renderEngine,\r\n      renderEngine: {hoverCanvas},\r\n      options: {map},\r\n    } = this\r\n    const {width, height} = map.getSize()\r\n    renderEngine.setCanvasSize(hoverCanvas, width, height)\r\n  }\r\n  getPoints() {\r\n    return this.points\r\n  }\r\n  getParams(point) {\r\n    let offset = this.normalOffset\r\n    let style = this.options.normalPointStyle\r\n    const isCluster = this.isCluster(point)\r\n\r\n    if (isCluster) {\r\n      offset = this.clusterOffset\r\n      style = this.options.clusterPointStyle\r\n    }\r\n    return {\r\n      isCluster,\r\n      offset,\r\n      style,\r\n      data: point,\r\n    }\r\n  }\r\n  isCluster(point) {\r\n    return point instanceof ClusterItem\r\n  }\r\n  isFunction(fn) {\r\n    return typeof fn === 'function'\r\n  }\r\n  destroy() {\r\n    clearTimeout(this.renderTimer)\r\n    this.eventEngine.off()\r\n    this.renderEngine.layer.hide()\r\n    this.data = null\r\n    this.points = null\r\n    this.renderData = null\r\n    this.clusterItems = null\r\n  }\r\n}\r\n"],"names":["Canvas","options","layer","hoverCanvas","hoverCanvasCtx","clusterCanvas","clusterCanvasCxt","pixelRatio","this","getPixelRatio","init","map","visible","zIndex","render","container","document","createElement","style","position","appendChild","getContext","AMap","CustomLayer","zooms","Math","min","round","window","devicePixelRatio","canvas","w","h","width","height","ClusterItem","point","renderPixel","points","coordinate","averageCenter","coordinateEngine","length","centerX","x","centerY","y","newCenterX","newCenterY","coordinateToPixel","centerPoint","push","updateCenter","pointX","pointY","gridSize","getGridSize","AmapCoordinate","data","renderData","bounds","getBounds","forEach","item","contains","_this","lngLatToContainer","lonLat2Mercator","lonLat","longitude","latitude","log","tan","PI","getOffsetValue","value","offset","trim","substr","Number","parseFloat","getOffset","Array","isArray","MercatorCoordinate","pow","getZoom","getExtendedBounds","southWest","getSouthWest","northEast","getNorthEast","tr","lng","lat","bl","pixel","atan","exp","Event","cluster","hoverPoint","click","clickHandler","mouseout","mouseoutHandler","mouseover","mouseoverHandler","mousemove","mousemoveHandler","zoomOnClick","bind","zoomstartHandler","initEvent","on","off","event","findPoint","params","getParams","isCluster","zoomOnClickHandler","isFunction","constains","renderHoverPoint","clearHoverPoint","Pixel","lnglat","containerToLngLat","setCenter","zoomIn","eventPixel","getPoints","i","offsetX","offsetY","x1","y1","x2","y2","Coordinate","MERCATOR","AMAP","defaultStyle","defaultOptions","maxZoom","minClusterSize","getPosition","location","hoverRender","normalPointStyle","clusterPointStyle","hoverNormalPointStyle","hoverClusterPointStyle","Cluster","clusterItems","Object","assign","normalOffset","clusterOffset","eventEngine","renderEngine","build","setData","rebuild","buildCusterItem","updatePoints","getRenderData","parent","distance","_this2","clusterItem","currDistance","addPoint","reduce","pre","curr","concat","getCount","delay","renderTimer","setTimeout","clearTimeout","clearCluster","index","_this3","getSize","setCanvasSize","fn","hide"],"mappings":"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"}