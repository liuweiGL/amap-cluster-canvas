{"version":3,"file":"amap-cluster-canvas.cjs.js","sources":["../src/canvas.js","../src/clusterItem.js","../src/amap.coordinate.js","../src/utils.js","../src/mercator.coordinate.js","../src/event.js","../src/cluster.js"],"sourcesContent":["/**\r\n * 为点聚合提供画布\r\n * @param options\r\n * {\r\n *   map: 地图,\r\n *   zIndex: 图层zIndex,\r\n *   visible: 是否可见\r\n * }\r\n */\r\nclass Canvas {\r\n  constructor( options ) {\r\n    this.layer = null\r\n    this.hoverCanvas = null\r\n    this.hoverCanvasCtx = null\r\n    this.clusterCanvas = null\r\n    this.clusterCanvasCxt = null\r\n    this.options = options\r\n    this.pixelRatio = this.getPixelRatio()\r\n    this.init()\r\n  }\r\n  init() {\r\n    const {\r\n      options: { map, visible, zIndex, render }\r\n    } = this\r\n    const container = document.createElement( 'div' )\r\n    // 绘制聚合点\r\n    const clusterCanvas = document.createElement( 'canvas' )\r\n    clusterCanvas.style.position = 'absolute'\r\n    // hover状态下的点绘制\r\n    const hoverCanvas = document.createElement( 'canvas' )\r\n    hoverCanvas.style.position = 'absolute'\r\n    container.appendChild( clusterCanvas )\r\n    container.appendChild( hoverCanvas )\r\n    this.clusterCanvas = clusterCanvas\r\n    this.hoverCanvas = hoverCanvas\r\n    this.clusterCanvasCxt = clusterCanvas.getContext( '2d' )\r\n    this.hoverCanvasCtx = hoverCanvas.getContext( '2d' )\r\n\r\n    this.layer = new AMap.CustomLayer( container, {\r\n      map,\r\n      zIndex,\r\n      visible,\r\n      zooms: [1, 20]\r\n    } )\r\n    this.layer.render = render\r\n  }\r\n  // 设备像素比\r\n  getPixelRatio() {\r\n    return Math.min( 2, Math.round( window.devicePixelRatio || 1 ) )\r\n  }\r\n  // 设置canvas的width&height属性可以清理画布\r\n  setCanvasSize( canvas, w, h ) {\r\n    const { pixelRatio } = this\r\n    canvas.width = w * pixelRatio\r\n    canvas.height = h * pixelRatio\r\n    canvas.style.width = w + 'px'\r\n    canvas.style.height = h + 'px'\r\n  }\r\n}\r\n\r\nexport default Canvas\r\n","class ClusterItem {\r\n  constructor( point, options ) {\r\n    this.renderPixel = null\r\n    this.points = [point]\r\n    this.coordinate = point.coordinate\r\n    this.averageCenter = options.averageCenter\r\n    this.coordinateEngine = options.coordinateEngine\r\n  }\r\n  getCount() {\r\n    return this.points.length\r\n  }\r\n  // 更新聚合点的中心点\r\n  updateCenter() {\r\n    const {\r\n      averageCenter,\r\n      points,\r\n      points: { length },\r\n      coordinate: { x: centerX, y: centerY }\r\n    } = this\r\n    if ( averageCenter ) {\r\n      const newAddPoint = points[length - 1]\r\n      const {\r\n        coordinate: { x: pointX, y: pointY }\r\n      } = newAddPoint\r\n      const totalX = centerX * ( length - 1 )\r\n      const totalY = centerY * ( length - 1 )\r\n      const newCenterX = ( totalX + pointX ) / length\r\n      const newCenterY = ( totalY + pointY ) / length\r\n      this.coordinate = {\r\n        x: newCenterX,\r\n        y: newCenterY\r\n      }\r\n      this.renderPixel = this.coordinateEngine.coordinateToPixel( this )\r\n    } else {\r\n      const centerPoint = this.points[0]\r\n      this.coordinate = centerPoint.coordinate\r\n      this.renderPixel = centerPoint.renderPixel\r\n    }\r\n  }\r\n  // 往聚合中添加点\r\n  addPoint( point ) {\r\n    this.points.push( point )\r\n    this.updateCenter()\r\n  }\r\n  // 判断一个点是否在改聚合范围内\r\n  contains( point ) {\r\n    const {\r\n      coordinate: { x: pointX, y: pointY }\r\n    } = point\r\n    const {\r\n      coordinate: { x: centerX, y: centerY }\r\n    } = this\r\n    const gridSize = this.coordinateEngine.getGridSize()\r\n    return (\r\n      pointX >= centerX - gridSize &&\r\n      pointX <= centerX + gridSize &&\r\n      pointY >= centerY - gridSize &&\r\n      pointY <= centerY + gridSize\r\n    )\r\n  }\r\n}\r\n\r\nexport default ClusterItem\r\n","export default class AmapCoordinate {\r\n  constructor( options ) {\r\n    this.map = options.map\r\n    this.gridSize = options.gridSize\r\n  }\r\n  getGridSize() {\r\n    return this.gridSize\r\n  }\r\n  getRenderData( data ) {\r\n    const renderData = []\r\n    const bounds = this.map.getBounds()\r\n    data.forEach( item => {\r\n      if ( bounds.contains( item.position ) ) {\r\n        // 经纬度转换为相对于地图容器的坐标\r\n        const coordinate = this.map.lngLatToContainer( item.position )\r\n        renderData.push( {\r\n          ...item,\r\n          coordinate,\r\n          renderPixel: coordinate\r\n        } )\r\n      }\r\n    } )\r\n    return renderData\r\n  }\r\n  coordinateToPixel( point ) {\r\n    return point.coordinate\r\n  }\r\n}\r\n","// 经纬度转墨卡托\r\nexport function lonLat2Mercator( lonLat ) {\r\n  const [longitude, latitude] = lonLat\r\n  let x = ( longitude * 20037508.34 ) / 180\r\n  let y =\r\n    Math.log( Math.tan( ( ( 90 + latitude ) * Math.PI ) / 360 ) ) / ( Math.PI / 180 )\r\n  y = ( y * 20037508.34 ) / 180\r\n  return {\r\n    x,\r\n    y\r\n  }\r\n}\r\n// 墨卡托转经纬度\r\nexport function mercator2LonLat( pixel ) {\r\n  const { x, y } = pixel\r\n  let longitude = ( x / 20037508.34 ) * 180\r\n  let latitude = ( y / 20037508.34 ) * 180\r\n  latitude =\r\n    ( 180 / Math.PI ) *\r\n    ( 2 * Math.atan( Math.exp( ( latitude * Math.PI ) / 180 ) ) - Math.PI / 2 )\r\n\r\n  return [longitude, latitude]\r\n}\r\n/**\r\n * 获取 offset 的值\r\n * @param {number} value\r\n * @param {any} offset\r\n * 1. offset 纯数字\r\n * 2. offset 百分比\r\n * 3. 默认返回 Number.parseFloat 的值\r\n */\r\nfunction getOffsetValue( value, offset ) {\r\n  const type = typeof offset\r\n  switch ( type ) {\r\n    case 'number':\r\n      return offset\r\n    case 'string':\r\n      const _offset = offset.trim()\r\n      if ( _offset.substr( -1 ) === '%' ) {\r\n        return value * ( Number.parseFloat( offset ) / 100 )\r\n      }\r\n      return Number.parseFloat( offset )\r\n    default:\r\n      return Number.parseFloat( offset )\r\n  }\r\n}\r\n// 解析 offset 参数\r\nexport function getOffset( style, offset ) {\r\n  if ( !Array.isArray( offset ) ) {\r\n    return [0, 0]\r\n  }\r\n  const { width, height } = style\r\n  return [getOffsetValue( width, offset[0] ), getOffsetValue( height, offset[1] )]\r\n}\r\n","import { lonLat2Mercator, mercator2LonLat } from './utils'\r\n\r\nexport default class MercatorCoordinate {\r\n  constructor( options ) {\r\n    this.map = options.map\r\n    this.gridSize = options.gridSize\r\n  }\r\n  getGridSize() {\r\n    return this.gridSize * Math.pow( 2, 18 - this.map.getZoom() )\r\n  }\r\n  getRenderData( data ) {\r\n    const renderData = []\r\n    const bounds = this.getExtendedBounds()\r\n    data.forEach( item => {\r\n      let { coordinate, renderPixel } = item\r\n      if ( !coordinate ) {\r\n        coordinate = lonLat2Mercator( item.position )\r\n        renderPixel = this.coordinateToPixel( item )\r\n      }\r\n      if ( this.contains( bounds, coordinate ) ) {\r\n        renderData.push( {\r\n          ...item,\r\n          coordinate,\r\n          renderPixel\r\n        } )\r\n      }\r\n    } )\r\n    return renderData\r\n  }\r\n  getExtendedBounds() {\r\n    const gridSize = this.getGridSize()\r\n    const bounds = this.map.getBounds()\r\n    const southWest = bounds.getSouthWest()\r\n    const northEast = bounds.getNorthEast()\r\n    // 上右\r\n    const tr = lonLat2Mercator( [southWest.lng, southWest.lat] )\r\n    // 下左\r\n    const bl = lonLat2Mercator( [northEast.lng, northEast.lat] )\r\n    tr.x -= gridSize\r\n    tr.y -= gridSize\r\n    bl.x += gridSize\r\n    bl.y += gridSize\r\n    return [tr, bl]\r\n  }\r\n  coordinateToPixel( point ) {\r\n    return this.map.lngLatToContainer(\r\n      point.position || mercator2LonLat( point.coordinate )\r\n    )\r\n  }\r\n  contains( bounds, coordinate ) {\r\n    const [tr, bl] = bounds\r\n    const { x, y } = coordinate\r\n    // 小于等于0 ：地图缩放到最小，世界地图都在视图内\r\n    return bl.x <= 0 || ( x >= tr.x && x <= bl.x && y >= tr.y && y <= bl.y )\r\n  }\r\n}\r\n","export default class Event {\r\n  constructor( cluster ) {\r\n    this.hoverPoint = null\r\n    this.cluster = cluster\r\n    this.map = cluster.options.map\r\n    this.click = cluster.options.clickHandler\r\n    this.mouseout = cluster.options.mouseoutHandler\r\n    this.mouseover = cluster.options.mouseoverHandler\r\n    this.mousemove = cluster.options.mousemoveHandler\r\n    this.zoomOnClick = cluster.options.zoomOnClick\r\n    this.initEvent()\r\n  }\r\n  initEvent() {\r\n    this.map.on( 'click', this.clickHandler.bind( this ) )\r\n    this.map.on( 'mousemove', this.mousemoveHandler.bind( this ) )\r\n    this.map.on( 'zoomstart', this.zoomstartHandler.bind( this ) )\r\n  }\r\n  clickHandler( event ) {\r\n    const { pixel } = event\r\n    const point = this.findPoint( pixel )\r\n    if ( point ) {\r\n      const params = this.cluster.getParams( point )\r\n      // 触发 `mouseout`\r\n      this.mouseoutHandler( point )\r\n      // 点击聚合点展开聚合\r\n      this.zoomOnClick && params.isCluster && this.zoomOnClickHandler( point )\r\n      this.cluster.isFunction( this.click ) && this.click( params )\r\n    }\r\n  }\r\n  // 由`mousemove`衍生出 `mouseout` & `mouseover`\r\n  mousemoveHandler( event ) {\r\n    const { pixel } = event\r\n    const hoverPoint = this.hoverPoint\r\n    const point = this.findPoint( pixel )\r\n    // 先触发 mouseout 事件\r\n    if ( hoverPoint && !this.constains( hoverPoint, pixel ) ) {\r\n      this.mouseoutHandler()\r\n    }\r\n    // 后触发 mouseover 事件\r\n    if ( point && hoverPoint !== point ) {\r\n      this.mouseoverHandler( point )\r\n    }\r\n    this.cluster.isFunction( this.mousemove ) && this.mousemove( event, point )\r\n  }\r\n  mouseoverHandler( point ) {\r\n    this.hoverPoint = point\r\n    const params = this.cluster.getParams( point )\r\n    this.cluster.renderHoverPoint( params )\r\n    this.cluster.isFunction( this.mouseover ) && this.mouseover( params )\r\n  }\r\n  mouseoutHandler() {\r\n    this.hoverPoint = null\r\n    this.cluster.clearHoverPoint()\r\n    this.cluster.isFunction( this.mouseout ) &&\r\n      this.mouseout( this.cluster.getParams( this.hoverPoint ) )\r\n  }\r\n  zoomstartHandler() {\r\n    this.mouseoutHandler()\r\n  }\r\n  zoomOnClickHandler( point ) {\r\n    const {\r\n      renderPixel: { x, y }\r\n    } = point\r\n    const pixel = new AMap.Pixel( x, y )\r\n    const lnglat = this.map.containerToLngLat( pixel )\r\n    this.map.setCenter( lnglat )\r\n    this.map.zoomIn()\r\n  }\r\n  // 查找鼠标下面的点，因为聚合点跟实体点的大小可能不一致，所以要分开查找\r\n  findPoint( eventPixel ) {\r\n    const data = this.cluster.getPoints()\r\n    const { length } = data\r\n    for ( let i = 0; i < length; i++ ) {\r\n      const point = data[i]\r\n      if ( this.constains( point, eventPixel ) ) {\r\n        return point\r\n      }\r\n    }\r\n    return null\r\n  }\r\n  // pixel 坐标是否在 point 范围内\r\n  constains( point, pixel ) {\r\n    const params = this.cluster.getParams( point )\r\n    const {\r\n      offset: [offsetX, offsetY],\r\n      style: { width, height }\r\n    } = params\r\n    const {\r\n      renderPixel: { x: x1, y: y1 }\r\n    } = point\r\n    const { x: x2, y: y2 } = pixel\r\n    return (\r\n      x2 >= x1 + offsetX &&\r\n      x2 <= x1 + width + offsetX &&\r\n      y2 >= y1 + offsetY &&\r\n      y2 <= y1 + height + offsetY\r\n    )\r\n  }\r\n}\r\n","import Canvas from './canvas'\r\nimport ClusterItem from './clusterItem'\r\nimport AmapCoordinate from './amap.coordinate'\r\nimport MercatorCoordinate from './mercator.coordinate'\r\nimport Event from './event'\r\nimport { getOffset } from './utils'\r\n\r\n// 开发环境输出日志\r\nconst debug = process.env.NODE_ENV === 'development'\r\n\r\n// 聚合策略\r\nexport const Coordinate = {\r\n  MERCATOR: 'MERCATOR', // 使用 墨卡托 坐标系\r\n  AMAP: 'AMAP' // 使用高德地图容器的相对坐标\r\n}\r\n\r\n// 默认的点样式\r\nconst defaultStyle = {\r\n  width: 60,\r\n  height: 69\r\n}\r\n// 聚合默认设置\r\nconst defaultOptions = {\r\n  data: null, // 数据集\r\n  coordinate: Coordinate.AMAP, // 聚合策略\r\n  maxZoom: 18, // 最大的聚合级别，大于该级别就不进行相应的聚合\r\n  gridSize: 60, // 聚合计算时，网格的像素大小\r\n  minClusterSize: 2, // 聚合的最小数量，小于该数量个点则不能成为一个聚合\r\n  averageCenter: true, // 是否取所有点的平均值作为聚合点中心\r\n  zoomOnClick: true, // 点击聚合点时，是否展开聚合\r\n  zIndex: 120, // canvas图层的zindex\r\n  visible: true, // 是否显示\r\n  offset: null, // 绘制图形相对于定位点的偏移度\r\n  getPosition( item ) {\r\n    // 获取经纬度信息\r\n    const { location } = item\r\n    const { longitude, latitude } = location || {}\r\n    return longitude && latitude ? [longitude, latitude] : null\r\n  },\r\n  render: null, // 绘制函数\r\n  hoverRender: null, // hover状态下的绘制函数\r\n  // 以下参数主要用于事件系统\r\n  clickHandler: null, // click事件\r\n  mouseoutHandler: null, // mouseout事件\r\n  mouseoverHandler: null, // mouseover事件\r\n  mousemoveHandler: null, // mousemove事件\r\n  normalPointStyle: defaultStyle, // 实体点的样式\r\n  clusterPointStyle: defaultStyle, // 聚合点的样式\r\n  hoverNormalPointStyle: defaultStyle, // hover状态下实体点的样式\r\n  hoverClusterPointStyle: defaultStyle // hover状态下聚合点的样式\r\n}\r\n\r\nexport default class Cluster {\r\n  constructor( options ) {\r\n    this.data = null\r\n    this.points = []\r\n    this.renderData = null\r\n    this.clusterItems = null\r\n    this.options = Object.assign( {}, defaultOptions, options )\r\n    // 解除 data 引用\r\n    this.options.data = null\r\n    this.normalOffset = getOffset( this.options.normalPointStyle, options.offset )\r\n    this.clusterOffset = getOffset(\r\n      this.options.clusterPointStyle,\r\n      options.offset\r\n    )\r\n    this.eventEngine = new Event( this )\r\n    this.renderEngine = new Canvas( {\r\n      map: this.options.map,\r\n      zIndex: this.options.zIndex,\r\n      visible: this.options.visible,\r\n      render: this.build.bind( this )\r\n    } )\r\n    this.coordinateEngine =\r\n      this.options.coordinate === Coordinate.AMAP\r\n        ? new AmapCoordinate( this.options )\r\n        : new MercatorCoordinate( this.options )\r\n    this.setData( options.data, false )\r\n  }\r\n  setData( data, rebuild = true ) {\r\n    const {\r\n      options: { getPosition }\r\n    } = this\r\n    this.data = []\r\n    if ( data ) {\r\n      data.forEach( item => {\r\n        const position = getPosition( item )\r\n        if ( position ) {\r\n          item.position = position\r\n          this.data.push( item )\r\n        }\r\n      } )\r\n    }\r\n    if ( rebuild ) {\r\n      this.build()\r\n    }\r\n  }\r\n  build() {\r\n    if ( debug ) {\r\n      console.time( '聚合构建时间：' )\r\n    }\r\n    this.buildCusterItem()\r\n    this.updatePoints()\r\n    this.render()\r\n    if ( debug ) {\r\n      console.timeEnd( '聚合构建时间：' )\r\n      console.log( '%c构建聚合模块数量：' + this.points.length, 'color: red' )\r\n    }\r\n  }\r\n  buildCusterItem() {\r\n    const options = {\r\n      coordinateEngine: this.coordinateEngine,\r\n      averageCenter: this.options.averageCenter\r\n    }\r\n    this.clusterItems = []\r\n    this.renderData = this.coordinateEngine.getRenderData( this.data )\r\n    this.renderData.forEach( point => {\r\n      let parent = null\r\n      let distance = -1 // 当前点与聚合中心的距离\r\n      const {\r\n        coordinate: { x: pointX, y: pointY }\r\n      } = point\r\n      this.clusterItems.forEach( clusterItem => {\r\n        if ( clusterItem.contains( point ) ) {\r\n          const {\r\n            coordinate: { x: centerX, y: centerY }\r\n          } = clusterItem\r\n          const currDistance =\r\n            Math.pow( pointX - centerX, 2 ) + Math.pow( pointY - centerY, 2 )\r\n          if ( distance < 0 || distance > currDistance ) {\r\n            // 取距离最近的一个聚合\r\n            parent = clusterItem\r\n            distance = currDistance\r\n          }\r\n        }\r\n      } )\r\n      if ( parent ) {\r\n        // 该点找到聚合对象\r\n        parent.addPoint( point )\r\n      } else {\r\n        // 以该点为中心创建一个聚合对象\r\n        const clusterItem = new ClusterItem( point, options )\r\n        this.clusterItems.push( clusterItem )\r\n      }\r\n    } )\r\n  }\r\n  updatePoints() {\r\n    const {\r\n      clusterItems,\r\n      options: { map, minClusterSize, maxZoom }\r\n    } = this\r\n    if ( map.getZoom() >= maxZoom ) {\r\n      // 地图放大最大层级，就不存在聚合点了\r\n      this.points = clusterItems.reduce(\r\n        ( pre, curr ) => pre.concat( curr.points ),\r\n        []\r\n      )\r\n    } else {\r\n      // 返回的点数据应该是聚合点+实体点\r\n      let points = []\r\n      clusterItems.forEach( clusterItem => {\r\n        if ( clusterItem.getCount() >= minClusterSize ) {\r\n          // 聚合点\r\n          points.push( clusterItem )\r\n        } else {\r\n          // 实体点\r\n          points = points.concat( clusterItem.points )\r\n        }\r\n      } )\r\n      this.points = points\r\n    }\r\n  }\r\n  renderLater( delay ) {\r\n    if ( !this.renderTimer ) {\r\n      this.renderTimer = setTimeout( this.render.bind( this ), delay || 50 )\r\n    }\r\n  }\r\n  render() {\r\n    const {\r\n      points,\r\n      options: { render },\r\n      renderEngine: { pixelRatio, clusterCanvasCxt }\r\n    } = this\r\n    if ( !this.isFunction( render ) ) {\r\n      return\r\n    }\r\n    if ( this.renderTimer ) {\r\n      clearTimeout( this.renderTimer )\r\n      this.renderTimer = null\r\n    }\r\n    if ( debug ) {\r\n      console.time( '绘制时间：' )\r\n    }\r\n    // 清理画布\r\n    this.clearCluster()\r\n    // 绘制\r\n    points.forEach( ( point, index ) => {\r\n      const params = this.getParams( point )\r\n      params.index = index\r\n      // 定位到中心位置\r\n      render(\r\n        clusterCanvasCxt,\r\n        point.renderPixel.x * pixelRatio,\r\n        point.renderPixel.y * pixelRatio,\r\n        params.style.width,\r\n        params.style.height,\r\n        params,\r\n        points\r\n      )\r\n    } )\r\n    if ( debug ) {\r\n      console.timeEnd( '绘制时间：' )\r\n    }\r\n  }\r\n  renderHoverPoint( params ) {\r\n    if ( this.isFunction( this.options.hoverRender ) ) {\r\n      const {\r\n        isCluster,\r\n        data: {\r\n          renderPixel: { x, y }\r\n        }\r\n      } = params\r\n      const {\r\n        renderEngine,\r\n        renderEngine: { hoverCanvasCtx },\r\n        options: { hoverRender, hoverNormalPointStyle, hoverClusterPointStyle }\r\n      } = this\r\n      const style = isCluster ? hoverClusterPointStyle : hoverNormalPointStyle\r\n      const { width, height } = style\r\n      const pixelRatio = renderEngine.getPixelRatio()\r\n      const canvasLeft = x * pixelRatio\r\n      const canvasTop = y * pixelRatio\r\n      hoverRender( hoverCanvasCtx, canvasLeft, canvasTop, width, height, params )\r\n    }\r\n  }\r\n  // 清除聚合\r\n  clearCluster() {\r\n    const {\r\n      renderEngine,\r\n      renderEngine: { clusterCanvas },\r\n      options: { map }\r\n    } = this\r\n    const { width, height } = map.getSize()\r\n    renderEngine.setCanvasSize( clusterCanvas, width, height )\r\n  }\r\n  // 清除 hover 点\r\n  clearHoverPoint() {\r\n    const {\r\n      renderEngine,\r\n      renderEngine: { hoverCanvas },\r\n      options: { map }\r\n    } = this\r\n    const { width, height } = map.getSize()\r\n    renderEngine.setCanvasSize( hoverCanvas, width, height )\r\n  }\r\n  getPoints() {\r\n    return this.points\r\n  }\r\n  getParams( point ) {\r\n    let offset = this.normalOffset\r\n    let style = this.options.normalPointStyle\r\n    const isCluster = this.isCluster( point )\r\n\r\n    if ( isCluster ) {\r\n      offset = this.clusterOffset\r\n      style = this.options.clusterPointStyle\r\n    }\r\n    return {\r\n      isCluster,\r\n      offset,\r\n      style,\r\n      data: point\r\n    }\r\n  }\r\n  isCluster( point ) {\r\n    return point instanceof ClusterItem\r\n  }\r\n  isFunction( fn ) {\r\n    return typeof fn === 'function'\r\n  }\r\n}\r\n"],"names":["Canvas","options","layer","hoverCanvas","hoverCanvasCtx","clusterCanvas","clusterCanvasCxt","pixelRatio","this","getPixelRatio","init","map","visible","zIndex","render","container","document","createElement","style","position","appendChild","getContext","AMap","CustomLayer","zooms","Math","min","round","window","devicePixelRatio","canvas","w","h","width","height","ClusterItem","point","renderPixel","points","coordinate","averageCenter","coordinateEngine","length","centerX","x","centerY","y","newCenterX","newCenterY","coordinateToPixel","centerPoint","push","updateCenter","pointX","pointY","gridSize","getGridSize","AmapCoordinate","data","renderData","bounds","getBounds","forEach","item","contains","_this","lngLatToContainer","lonLat2Mercator","lonLat","longitude","latitude","log","tan","PI","mercator2LonLat","pixel","atan","exp","getOffsetValue","value","offset","trim","substr","Number","parseFloat","getOffset","Array","isArray","MercatorCoordinate","pow","getZoom","getExtendedBounds","southWest","getSouthWest","northEast","getNorthEast","tr","lng","lat","bl","Event","cluster","hoverPoint","click","clickHandler","mouseout","mouseoutHandler","mouseover","mouseoverHandler","mousemove","mousemoveHandler","zoomOnClick","initEvent","on","bind","zoomstartHandler","event","findPoint","params","getParams","isCluster","zoomOnClickHandler","isFunction","constains","renderHoverPoint","clearHoverPoint","Pixel","lnglat","containerToLngLat","setCenter","zoomIn","eventPixel","getPoints","i","offsetX","offsetY","x1","y1","x2","y2","Coordinate","MERCATOR","AMAP","defaultStyle","defaultOptions","maxZoom","minClusterSize","getPosition","location","hoverRender","normalPointStyle","clusterPointStyle","hoverNormalPointStyle","hoverClusterPointStyle","Cluster","clusterItems","Object","assign","normalOffset","clusterOffset","eventEngine","renderEngine","build","setData","rebuild","buildCusterItem","updatePoints","getRenderData","parent","distance","_this2","clusterItem","currDistance","addPoint","reduce","pre","curr","concat","getCount","delay","renderTimer","setTimeout","clearTimeout","clearCluster","index","_this3","getSize","setCanvasSize","fn"],"mappings":"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"}